% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{subcaption}

\graphicspath{ {./images/} }
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=blue,
    citecolor=blue,
    urlcolor=blue,
    linktocpage=true
}
\setcounter{tocdepth}{2} %show more in the toc

\newcommand{\kw}[1]{\texttt{#1}}
\renewcommand{\contentsname}{table of content}
\usepackage{indentfirst}
\usepackage[english]{babel}

% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

%

\title{MetaData262: Computing and Visualizing Test262 MetaData}
\subtitle{}

%
\titlerunning{MetaData262: Computing and Visualizing Test262 MetaData}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Diogo Costa Reis\\ist187526\\
\email{diogo.costa.reis@tecnico.ulisboa.pt}}
%
\authorrunning{Diogo Costa Reis}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Instituto Superior TÃ©cnico\\
Av. Rovisco Pais, 1\\
1049-001 Lisboa\\
Tel: +351 218 417 000\\
\email{mail@tecnico.ulisboa.pt}}
%


\begin{document}

% a solution to remove title and author from appearing in the table of contents: https://tex.stackexchange.com/a/318220
{\def\addcontentsline#1#2#3{}\maketitle}

%
\begin{abstract}
The ECMAScript standard is the specification of the Java-Script language which is one of the most popular programming languages in the world. Implementing the ECMAScript standard is challenging in various ways, both due to its complexity and its scale. Test262 was created to alleviate this difficulty by providing a comprehensive test suite that allows developers to test their implementations. 
%
However, Test262 does not come to a structured description of its tests, making it impossible to filter tests by the JavaScript features they target. The MetaData262 v0 system was created to help with this issue, providing a database containing the metadata of Test262 tests and a collection of scripts to compute that metadata.
%
With this thesis, we will improve MetaData262 v0 in two separate ways. First, we will re-engineer the system for metadata computation, making it more precise and performant and enriching the computed metadata with additional information. Second, we will develop a web interface for the visualization of Test262, allowing developers to easily filter tests by feature. 

\keywords{ECMAScript \and Specification Language \and Reference Interpreters \and Test262}
\end{abstract}


\newpage

\tableofcontents

\newpage

\section{Introduction}
\label{sec:Introduction}


% paragrafo - porque e' que javascript e' relevante (uma das linguagens mais usadas no momento)
JavaScript (JS) is a programming language mainly used in the development of client-side web applications, also being one of the most popular programming languages. According to both GitHub and StakeOverflow statistics, JavaScript finished 2021 as the second most active language on GitHub\footnote{Second most utilized language based GitHub pull requests - https://madnight.github.io/githut/} as well as on StackOverflow.\footnote{Tendencies based on the Tags used - https://insights.stackoverflow.com/trends}


% Para 2 --> implemetar JS e' dificil: complexidade tamanho
% Para 2.5 --> Test262 ajuda a implementar permitindo testar implementacoes --> test262 tambem e' grande dificil selecionar os testes apropriados
JavaScript is defined in the \texttt{ECMAScript} standard~\cite{ECMAScript}, a document written in English. The standard has been growing with each new version, both in size and complexity. The growth of the standard is illustrated in Figure \ref{fig:paginas_standard_version}. This continuous growth in complexity makes the JavaScript a language very hard to implement with many corner cases. \texttt{Test262}~\cite{Test262} was created to aid the development of JavaScript engines by providing a conformance test suite that developers can use to test their implementations. As the standard is extensive and complex, a conformance test suite for JavaScript must necessarily be very large given that it must cover all the corner cases of the standard. The standard being complex and extensive also leads to many of its implementations being only partial, particularly those made in academic contexts, for example JSRef~\cite{JSCert-2014} and JISET~\cite{JISET-2020}.


\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth]{images/standard_pages_evolution.png}
    \caption{Evolution of ECMAScript standard's number of pages}
    \label{fig:paginas_standard_version}
\end{figure}



% Para 4 --> MetaData v0 calcula metadata --> disponibiliza mongoDB

When implementing a JavaScript engine or a JavaScript analysis, it is very important to know the tests that should pass for the specific feature being implemented. The selection of applicable tests for partial implementations is particularly difficult since tests for one feature may or may not use other features that are not implemented. For instance, a test targeting the Math library might use features of the array library. \texttt{MetaData262 v0} is a project developed at IST with the goal of facilitating this problem. In particular, MetaData262 v0 processes the \texttt{Test262} test suite and calculates metadata about the tests, storing that metadata in a NoSQL database that can be easily inspected. \texttt{MetaData262 v0} stores for each test various properties, such as the JavaScript version to which the test belongs, the syntactic constructs that are used in the test, and the built-ins that are used by the test.


% --> eu vou melhorar metadata
% Para 5 --> Visualization system permite interagir com a metadata via web com interface simples --> filtrar; verdados varias maneiras; estatisticas
In this thesis we will improve \texttt{MetaData262 v0} in two ways. First, we will develop a \texttt{MetaData262 v1}, a new version of MetaData262 with an improved infrastructure for computing the metadata of Test262 tests, making it more precise and extending it with additional information. Second, we will build \texttt{MetaData262Viz}, a web application for the visualization of the metadata that will allow the developers to easily select tests per feature and obtain statistics regarding the selected testes.

% Para 5.1 --> improve MetaData262 v0
As described above, MetaData262 v1 will improve MetaData262 v0 in the following ways. Below, we give a brief overview of the most relevant improvements:

\begin{itemize}
\item \emph{Better Precision:} MetaData262 v0 computes for each test the version to which the test belongs and the built-in objects with which the test interacts. Unfortunately, this computation is far from precise as it relies on the specific implementations of JavaScript engines. For instance, MetaData262 v0 determines that a test is meant for version 5 if a JS engine implementing version 5 passes the test. Naturally, this approach is not error-free since it is never the case that a JS engine implements one and only one version of the language fully. To improve precision, we will build a dedicated infrastructure to streamline the addition of new JavaScript engines to our metadata computation pipeline and use this new infrastructure to compute a new version of the metadata.
%
\item \emph{Better Performance} As said before, the metadata computation pipeline of MetaData262 v0 requires running various JS engines on each test of Test262. This is extremely time consuming given the high number of tests contained in Test262 (around 40K). 
Currently this is done sequentially. To improve on this situation, we will associate each JavaScript engine with a docker container and run the docker containers in parallel. With docker containers running in parallel the scalability and performance of \texttt{MetaData262 v1} will improve. In addiction to that, the JavaScript engines being associated with docker containers will also make \texttt{MetaData262 v1} easier to replicate.
%
\item \emph{More information:} We will extend the computed metadata of each test with additional information. In particular, we plan to associate with each test: (1) the date in  which the test was introduced and (2) the harness files and functions that the test uses. Basically, the Test262 harness is a set of files that contain auxiliary functions used by Test262 tests, such as assert and assertEquals. 
\end{itemize}


% Para 5.2 --> build MetaData262 visualization system
MetaData262Viz will be a visualization system for the metadata computed with MetaData262 v1. In particular, MetaData262Viz will allow developers to filter Test262 tests by feature and to obtain statistics about the selected tests. The statistics will generate charts built in real time with the metadata of the tests selected. Some examples of those charts to generate are a bar charts with the amount of tests per version and a pie chart with the the amount of tests per built-in used.
We have already developed a prototype of MetaData262Viz built with Node.js~\cite{Node.js} and React~\cite{React}. The prototype already allows filtering the tests by their version and the built-ins used. As for the output, it can already display the full metadata or just the path of the tests selected.


% Para 6 --> resumo do resto do relatorio
This document is structured in the following way. Section \ref{sec:Goals} has the objectives of this thesis. Section \ref{sec:Background} gives an overview of the field of the thesis, describing the \texttt{ECMAScript} standard, the \texttt{Test262} test suite, and the project \texttt{MetaData262 v0}. Next, Section \ref{sec:Related Work} presents the scientific work done that relates to this thesis topic. Section \ref{sec:Design and Methodology} presents the design and methodology that will be be followed in this thesis. As for Section \ref{sec:Evaluation and Planning}, it describes how we plan to evaluate the results of this thesis as well as its timeline. Finally, Section \ref{sec:Conclusion} presents the main conclusions and a summary of this proposal. 



\section{Goals}
\label{sec:Goals}


This thesis has two main goals. The first is to improve \texttt{MetaData262 v0} and the second is to create a web visualization system to make the metadata more accessible.
%
In the end, we hope that developers of JS engines and analyses will use the MetaData262Viz for filtering Test262 tests per feature, making the test selection process more efficient, effective, and reliable.

\paragraph{MetaData262 v0 improvements}
This goal is to improve the precision and performance of MetaData v0 making it more complete, scalable, and easier to replicate.

\paragraph{MetaData262Viz}
This goal aims to create a web platform to easily visualize the metadata calculated by \texttt{MetaData262 v0}. The system will provide filters with which the developer will be able to filter Test262 tests by their features. Then, the system will output the filtered tests in various formats as well as useful statistics about them.


\section{Background}
\label{sec:Background}
This chapter provides an overview on the ECMAScript standard, the Test262 that are used to test the correct implementation of the ECMAScript standard, and finally an outline of the new metadata generated.

\subsection{ECMAScript}
\label{subsec:ECMAScript}
% overview da linguagem JS



% Existem muitas implementacoes diferentes da linguagem: client-side (browsers), server-side (Node.js), embedded devices (Jerryscript) -> Estas implementacoes tÃªm de estar de acordo no comportamento observavel -> Ã© particularmente importante na Web -> senao temos sites que em ...
% -----------------------
% overview do standard -> descrita num standard
% Porque Ã© muito importante que as vÃ¡rias implementacoes da linguagem coincidam -> o JavaScript estÃ¡ especificado num documento semi-formal que ...
% Falar sobre o standard
%   - o standard estÃ¡ como um interpretador de JavaScript em
%     pseudo-codigo - descreve detalhadamente os passos que
%    um interpretador de JS tem de executar ao avaliar qualquer
%    statement da linguagem
% Falar sobre o comitÃ© -  quem controla a evolucao do ECMAScript
ECMAScript standard is the official document, written in the English language, in which the JavaScript language is defined. This document is in constant evolution, being updated by the ECMA Technical Committee 39 (TC39), which is responsible for maintaining the standard. The standard is currently in its twelfth version. 
%
The standard specifies the \texttt{JavaScript} language, to ensure its multiple compilers and interpreters implementations are coherent. Some of the \texttt{JavaScript} compilers are the Hop~\cite{Hop} and the JSC~\cite{JSC} compilers, the most popular interpreters are Node.js and SpiderMonkey~\cite{SpiderMonkey}. These are only four implementations among many others, which come along with the many use cases that \texttt{JavaScript} has.
%
\texttt{JavaScript} is mostly used in the web context, both client-side within browsers and server-side, but also in embedded devices. Since \texttt{JavaScript} is used in so many scenarios and across so many different contexts, it is highly important that ECMAScript standard is defined in great detail to ensure consistency. Browsers, for example, need to run \texttt{JavaScript} implementations that coincide so that websites are correctly rendered and exhibit the same behavior. In order to achieve coherent implementations, the standard defines the types, values, objects, properties, syntax, and semantics of \texttt{JavaScript} that must be the same in every \texttt{JavaScript} compiler and interpreter, while allowing \texttt{JavaScript} implementations to define additional types, values, object, properties, and functions.




% Estrutura do standard
The \texttt{JavaScript} language can be divided into three major components, those being expressions and commands, built-in libraries, and finally internal functions.
%
\begin{itemize}
\item Expressions and commands describe the behavior of static constructions, detailing the semantics of the diverse expressions (e.g., assignment expressions, built-in operators, etc.), commands (e.g., loop commands, conditions command, etc.), and built-in types (Undefined, Null, Boolean, Number, String and Object).
%
\item The internal functions of the language are used to define the semantics for both expressions and commands, as well as the built-in libraries. Internal functions are not exposed beyond the internal context of the language. In other words, no JavaScript program uses internal functions directly.
%
\item Finally, built-in libraries encompass all the internal objects available when a JavaScript program is executed. Internal objects expose many functions implemented by the language itself, including functions to manipulate numbers, text, arrays, objects, among other things.
\end{itemize}


% MetaParagrafo tres tipos
The remaining subsection provides a description of the three types of artifact described in the standard.


% Expressions and statements
% Exemplo do standard  e explicacao (if)
\paragraph{Semantics of IF statement}
Figure \ref{fig:If-Else_Statement} shows a snippet of the ECMAScript standard description of the \texttt{IF} command. In order to evaluate \texttt{IF} commands with the shape:

\begin{center}
\texttt{if (Expression) Statement1 else Statement2}
\end{center}

\noindent the language begins by evaluating the \texttt{Expression} storing the result in the variable \texttt{exprRef} (step 1). The previous step will be used as Boolean, therefore, the result of the previous step will be converted to a Boolean using the internal functions \texttt{ToBoolean} and \texttt{GetValue}, and having the result stored in the variable \texttt{exprValue} (step 2).A different \texttt{Statement} will be followed depending on \texttt{exprValue}. If \texttt{exprValue} has the value \texttt{true} the variable \texttt{stmtCompletion} will have the evaluation of the first \texttt{Statement} (step 3). Otherwise, the variable \texttt{stmtCompletion} will store the result of evaluating the second \texttt{Statement} (step 4). Finally, a \texttt{Completion} will be returned, if the \texttt{stmtCompletion} has non empty value then it will be returned, however, when the value is empty it will be replaced with undefined (step 5).

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{images/if_statement.png}
    \caption{ECMAScript definition of an if-else statement}
    \label{fig:If-Else_Statement}
\end{figure}

% arrays sÃ£o objetos como os outros
% arrys tem propriedades especiais
% example of Array.pop
% Built-ins (Array.pop)
% printscreen do standard e explicacao
\paragraph{Semantics of the Pop function}
The Array built-in is an object as any other in JavaScript. The main difference is in its properties. Array Objects have a property \texttt{length} that contains the size of the array, as well as a property for each element of the array (from zero to \texttt{length} minus 1).

Figure \ref{fig:Array_pop_example} shows a simplified version of an array performing the pop function, where \texttt{(a)} and \texttt{(b)} are the before and after respectively.
Before performing \texttt{pop} \texttt{(a)}, the array has three  properties \texttt{length}, \texttt{0}, and \texttt{1}. Property \texttt{length} represents the size of the array that has value \texttt{2}, while the properties \texttt{0} and \texttt{1} store the first (\texttt{banana}) and second (\texttt{kiwi}) elements of the array respectively.
After \texttt{pop} is performed \texttt{(b)}, the last element is of the array is removed (highlighted in red at \texttt{(a)}) and the \texttt{length} property (highlighted in green) is decremented by one since the size of the array changes to one.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\textwidth]{images/array_pop_example.png}
    \caption{Example Array.pop}
    \label{fig:Array_pop_example}
\end{figure}
Figure \ref{fig:Array_pop} shows a snippet of the ECMAScript standard description of the pop function in the Array Built-in. To begin with, the array will be converted to and Object using the \texttt{ToObject} function, and stored in the \texttt{O} variable (step 1).
Afterwards, the array length of the previously calculated variable will be calculated with the \texttt{LengthOfArrayLike} internal function, and storing the result in the \texttt{len} variable (step 2).
At this point there are to ways to proceed depending on the value of \texttt{len}. If the value is zero, the Array is empty, then the property \texttt{length} of \texttt{O} is set to zero and \texttt{undefined} is returned (step 3).
Otherwise, when \texttt{len} is different from zero, meaning that the Array is not empty, the Array's last element will be removed (described in Figure \ref{fig:Array_pop_example}) and returned (step 4).
To begin with, the language will assert that \texttt{len} is positive (step 4.a).
Afterwards, the \texttt{newLen} variable will store the value of \texttt{len} decremented by 1 (step 4.b).
The variable \texttt{index} will store the variable calculated in the previous step represented as a String converted with the \texttt{toString} function (step 4.c).
Then, stores the value of the \texttt{O} variable at the property corresponding to \texttt{index} in the \texttt{element} variable using the \texttt{Get} function (step 4.d).
Subsequently, deletes the previously mentioned property of the \texttt{O} variable with the \texttt{DeletePropertyOrThrow} function (step 4.e).
In addition, sets the \texttt{length} property of the \texttt{O} variable  to the \texttt{newLen} using the \texttt{Set} function (step 4.f).
Finally, returning the value of the variable \texttt{element} (step 4.g).

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth]{images/array_pop.png}
    \caption{ECMAScript definition of Array.pop}
    \label{fig:Array_pop}
\end{figure}



% Internal Functions (LenghtOfArrayLike)
% printscreen do standard e explicacao
\paragraph*{LengthOfArrayLike internal function}
Figure \ref{fig:LengthOfArrayLike} shows a snippet of the ECMAScript standard description of the \texttt{LengthOfArrayLike} internal function, that evaluates the function:

\begin{center}
\texttt{LengthOfArrayLike (obj)}
\end{center}

\noindent The language starts by asserting that \texttt{obj} is an \texttt{Object} (step 1). Afterwards, gets the value of the property \texttt{length} from \texttt{obj} using the function \texttt{Get}. Then, converts the previously mentioned value to an Integer that represents the length with the \texttt{ToLength} function, and finally returns said Integer (step 2).

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{images/length_array_like.png}
    \caption{ECMAScript definition of the LengthOfArrayLike}
    \label{fig:LengthOfArrayLike}
\end{figure}




\subsection{Test262}
\label{subsec:Test262}


% paragrafo - JS tem muitas particularidades que dificultam o desemvolvimento e testagem  -> Ã muito dificil desenvolver
% novas implemenentacoes da linguagem
% Existe uma bateria de testes que testa as implementacoes da
% linguagem contra o standard
% Esta bateria de testes Ã© dificil de manter
% Porque? - muitos testes, muitas features, em geral ha retrocompatibilidade mas ha um pequeno numero de casos onde a retrocompatibilidade nao se verifica -> os testes de ser modificados
Implementing a \texttt{JavaScript} engine is particularly difficult since it involves dealing with the many corner cases that exist in the language. To test that corner cases are correctly dealt with there is \texttt{Test262}, the ECMAScript standard test battery. Although, \texttt{Test262} is vital to the \texttt{JavaScript} engines, it is very hard to maintain due it's complexity, the total number of tests is around 40000 divided into 87 subfolders, each correspond to roughly one section of the standard. \texttt{Test262} complexity grows with changes to the standard since in most cases backward compatible is maintained except for a few select cases. 
% 87 subfolders on built-ins + language
% QUESTION round number? (40000)
% QUESTION 105 subfolders if add intl402 (which also has files that were ignore)



% Implementacoes parciais da linguagem 
% Na acadamia Ã© normal desenvolverem-se implementacoes parciais da linguagem: nÃ£o suportam a ultima versao, nÃ£o suportam todos os objectos built-in, nÃ£o suportam todas
% Pergunta: Quais Ã© que sÃ£o os testes apropriados?
% Normal: Respostas ad-hoc -> sem justificaÃ§Ã£o rigorosa -> basicamente cada paper selecciona os testes que lhe da jeito
Due to the ECMAScript standard being so extensive most implementations are only partial, especially implementations and analysis developed in academic contexts. In order to test partial implementations, one must be able to obtain the applicable set of tests from all the tests contained in Test262. Selecting the applicable tests is not a trivial matter because there are too many tests and too many features. The current methodology is that each development team manually selects the tests that are applicable to their corresponding implementation. This raises the problem that there is not standard and precise way of picking the all the right tests from the almost 40000 tests in \texttt{Test262}, making the possibility of human error when selecting the applicable tests likely.


% gosto
%% Formato dos testes
% frontmatter, code
% exemplo
Figure \ref{fig:Test262_example} shows a test from \texttt{Test262}. Every test of \texttt{Test262} has 3 parts: first is the copyright section represented with the comment \texttt{//} (lines 1 and 2), second is the \texttt{Frontmatter} section between \texttt{/*---} and \texttt{---*/} with some metadata about the test (lines 4 to 7), and finally is the \texttt{Body} section with the code of the test (lines 9 to 13). The copyright section has information about the owner and license of the test. The \texttt{Frontmatter} section has the test id (15.4.5-1) and a description of the test. Finally, the \texttt{Body}'s code tests the correct implementation of the standard.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1.0\textwidth]{images/test262_array_test.png}
    \caption{Test262 es5id: 15.4.5-1}
    \label{fig:Test262_example}
\end{figure}



%% metadados ja incluidos
%% referir outra vez o exemplo
% - metadados oficialmente incluÃ­dos nos testes
%   - que metadados Ã© que os testes contÃ©m actualmente
The \texttt{Frontmatter} has keywords to hold metadata of the test. These keywords are associated with specific elements of metadata concerning the test. Bellow is the list of possible keywords and their meaning:

\begin{itemize}
\item \texttt{description} - contains a short description about what will be tested;
%
\item \texttt{esid} - contains the hash identifier of the ECMAScript portion associated with the feature that will be tested (the identifier references the most recent version of ECMAScript when the test is created);
%
\item \texttt{info} - contains a deeper explanation of the test behavior, frequently includes a direct citation of the standard;
%
\item \texttt{negative} - indicates that the test throws an error; associated to the keyword will be the type of error the test is supposed to be thrown (e.g. \texttt{TypeError}, \texttt{ReferenceError}) as well as the phase in which the error is expected to be thrown (e.g. \texttt{parse} vs \texttt{resolution} vs \texttt{runtime});
%
\item \texttt{includes} - contains the list of \texttt{harness} files that should be included in the execution of the tests (\texttt{Test262} makes use of a large number of auxiliary function defined in a dedicated library referred to as the \texttt{Test262} \texttt{harness} described later in this section);
%
\item \texttt{author} - contains the identification of the author of the test;
%
\item \texttt{flags} - contains a list of booleans for each test property, the properties being: (1) \texttt{onlyStrict}, the test is only executed in strict mode; (2) noStrict, the test will only be executed in mode \emph{sloppy}; (3) \texttt{module}, the test must be integrated as a \texttt{JavaScript} module; (4) \texttt{raw}, executes the test without any modification, which implies running as \texttt{noStrict}; (5) \texttt{async}, the test is contains asynchronous functions; (6) \texttt{generated}, the test generates the files specified by the property; (7) \texttt{CanBlockIsFalse} and (8) \texttt{CanBlockIsTrue}, the test will run if the property \texttt{CanBlock} of the \texttt{Agent Record} executing it is false and true respectively; (9) \texttt{non-deterministic}, indicates that the semantics used in the test are intentionally under-specified and therefore the test passing or failing should not be regarded as an indication of reliability or conformance;
% QUESTION clarificar se e' necessario citar o que e' 'Agent Record' uma vez que nao vou explicar
%
%
\item \texttt{features} - contains a list of features that are used in the test;
%
\item \texttt{es5id} and \texttt{es6id} - indicates that the feature being tested belongs to ECMAScript 5 and 6 respectively and contains the hash identifier of the section of the standard it belongs to; these keywords have been deprecated and substituted by esid.
\end{itemize}


% Varias observacoes: 
%  - A metada esta muitas vezes INCOMPLETA e algumas vezes incorrecta 
%  - Ã© preciso calcular a metadata certa
As Figure 5 illustrates, it is often the case that the metadata of a test is incomplete. Some tests also have the wrong metadata. As part of this thesis, we plan to process all the tests to check and correct their corresponding metadata as well as completing the metadata that is missing.

%% QUESTION juntar os paragrafos?

%% metadados que achamos relevantes e nao estao incluidos
%% ...
The example in Figure \ref{fig:Test262_example} has 2 keywords, description and the deprecated es5id. Besides the obvious upgrade from \texttt{es5id} to \texttt{esid} it would be useful to have \texttt{includes} with the \texttt{harness} files needed to execute the test. The \texttt{harness} information is very useful since it makes it easy to identify the part of the \texttt{harness} needed to run that test, opening the door for loading only part of the \texttt{harness} instead of the whole \texttt{harness} which is the current approach.



% - quais sÃ£o os metadados que nÃ³s achamos serem relevantes e que estÃ£o em falta
\paragraph{New Metadata}
Besides the metadata that Test262 tests currently include, it would be useful for them to have additional information regarding:

\begin{itemize}
    \item \texttt{syntactic construct} - list of all syntactic constructions used in the test;
    \item \texttt{version} - the ECMAScript version of the standard in which the feature being tested was introduced;
    \item \texttt{built-ins} - list of all the built-ins used in the test.
    \item \texttt{harness-functions} - list of all the harness functions required to run the test.
\end{itemize}

This above metadata critical for filtering the tests when considering partial implementations of the language. For instance, if a JS engine only supports the 5th edition of the standard, one must be able to obtain all the corresponding tests for that \texttt{version}. Analogously, if a JS engine only implements certain \texttt{built-in} objects, one has to be able to filter out the tests that make use of the \texttt{built-in} objects that it does not implement. This would provide consistency and standardization to the selection of applicable tests to a partial implementation of the standard.
%
As for the \texttt{harness-functions}, it provides important information about the functions of \texttt{harness} that are used in the test. That information is relevant because only a small part of the \texttt{harness} is need in each test even though the whole library is loaded and tested. The harness has a total of 7290 lines in 32 files and is tested by 96 tests. By only including the exact functions that a test requires, one can speedup the testing process significantly.
% harness - has 32 files total 7290 lines (comments and blanck lines included)
% harness tests - has 96 files total 2646 lines (comments and blanck lines included)



\subsection{MetaData262 v0}
\label{subsec:MetaData262 v0}



% Para1 --> introduzir o trabalho do Miguel Trigo 
This thesis continues the master thesis of Miguel Trigo\cite{MetaDataV0}, in which he developed a preliminary version of \texttt{MetaData262}. More specifically, he built a MongoDB database storing the metadata of all Test262 tests, representing the metadata of each test as a JSON object.



% Para2 --> estrutura da metadata
In \texttt{MetaData262 v0}, each test is associated with a JSON object storing the various metadata properties of the test and their corresponding values, with those metadata properties being the keywords of the \texttt{Frontmatter} mentioned in the previous section.
%
Besides the existing metadata properties, various new properties were added to \texttt{MetaData262 v0}. We can divide these new properties into 3 main groups: location properties, extra front matter properties, and statistics properties. Each of these groups will be discussed next.

% Para 2.1 [path] (location)
\paragraph{Location group}
The location group contains information about the path to the test inside the \texttt{Test262}. It consists of the properties \texttt{path}, storing the relative path to the test starting at the root of the \texttt{Test262} project, and splitPath, storing the array obtained by splitting the \texttt{path} string into its corresponding folders.


% Para 2.2 [extra front matter: syntactic constructs, built-ins, version] 
\paragraph{Extra front matter group}
The extra front matter group contains new metadata generated for \texttt{MetaData262 v0}. The new metadata generated is associated with the properties: \texttt{syntactic\_constructs}, \texttt{version}, and \texttt{builtIns} that were mentioned in the previous section as important metadata to add. The property \texttt{version} stores the \texttt{ECMAScript} standard version the test belongs to. The property \texttt{syntactic\_construct} stores an array with all the syntactic constructions that the test contains. As for \texttt{builtIns}, it stores all the built-ins that the test interacts with, mapping each built-in to its fields and methods used by test. 


% Para 2.3 [statistics]
\paragraph{Statistics group}
Finally, the statistics group contains some statistical data about the tests. It contains the properties: \texttt{asserts}, \texttt{error}, \texttt{esprima}, and \texttt{lines}. The \texttt{asserts} property holds the amount of \texttt{assert} statements in the test. The \texttt{error} property stores the amount of calls made to \texttt{Test262} error functions. The \texttt{esprima} property stores a boolean value indicating whether or not the Esprima\cite{Esprima} parser supports the test. \texttt{Esprima} is a standard-compliant \texttt{ECMAScript} parser fully developed in \texttt{ECMAScript}; \texttt{Esprima} fully supports up to version 7 of the standard. The property \texttt{lines} holds the number of lines of code the test has, excluding comments and empty lines.



\subsubsection{Example}

% Para3 --> exemplo da MetaData262 v0
Figure \ref{fig:json_metadata} shows the JSON object storing the metadata generated from the Test262 test given in Figure \ref{fig:Test262_example}. 
% Observacoes sobre o exemplo 
The JSON object begins with the \texttt{path} property storing the path to the test at hand. After, the \texttt{version} property indicates that this test belongs to the fifth version of the standard. If \texttt{MetaData262 v0} was not able to compute the version of the test, this field is omitted. Next, we have the properties corresponding to the test's \texttt{Frontmatter} (note that the deprecated \texttt{es5id} is replaced to the \texttt{esid} property).
% ignorar as propriedades buit-ins e Array
Next we have the \texttt{static\_constructs} property that holds an array with the syntactic constructors of the test. The \texttt{builtIns} property holds a JSON object, in which, each property corresponds to a built-in mapped to its functions and fields that are interacted with in the test. Finally, we have the statistics group of properties. The \texttt{asserts} property indicates that this test uses one assert statement. The \texttt{error} holds the numeric value zero since this test uses no error functions of \texttt{Test262}. The \texttt{esprima} property indicates this test is supported by \texttt{Esprima}. Finally, the \texttt{lines} property indicates that this test has 3 lines of code. Note that the example in Figure \ref{fig:Test262_example} splits the last line of the test in order to improve the readability of the figure hence only 3 lines are counted in the actual test).


\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth]{images/json_metadata.png}
    \caption{Metadata generated for test esid: 15.4.5-1.js}
    \label{fig:json_metadata}
\end{figure}



\subsubsection{Metadata Computation}

% Para4 --> a metada original em falta teve de ser calculada e os 
% // bem como os novos campos da metadata -> 
As part of the setting up of MetaData262 v0,  M. Trigo had to compute the missing \texttt{Frontmatter} properties as well as the values of the new properties that he introduced. In most cases, the computation was straightforward, only involving a simple syntactic analysis of each test. However, the computation of the version and the built-ins used in each test was more involved. We will go through this process in more detail below.

% Para5 --> Version Computation 
\paragraph{Calculation of Version metadata}
The \texttt{version} of the standard a test belongs to is calculated using 3 different approaches: dynamic, static, and hybrid.Below we give a brief overview of each method:

\begin{itemize}
  \item \emph{Dynamic Approach:}
The dynamic approach is based on the waterfall model, running the tests in various JS engines, each corresponding to a specific version of the standard. As Figure \ref{fig:waterfall_model} illustrates, \texttt{MetaData262 v0} starts by running each test in the JS engine corresponding to version 5 of the \texttt{ECMAScript} standard (represented as ES). If the test output is correct then the test is labelled as belonging to version 5 of the standard, otherwise the test will be run in the engine implementing the next version of the standard. This process repeats until the last engine, associated with version 11 of the standard. If the test output is not the expected again, then the test is not supported.
%
  \item \emph{Static Approach:}
The static approach determines the version of a test by analyzing the static keywords of the test. Essentially, a test is labeled with the version corresponding to the keyword with the latest associated version; formally:
\[version(test) = max \{ version(keyword) | keyword \in test \} \]
For instance, if a test contains two keywords introduced in versions 6 and 8, then the test will belong to the version 8 of the standard. \texttt{MetaData262 v0} implements the static approach in the following way. It maintains an internal map associating each keyword with the version in which it was introduced. Given a test to be labeled, \texttt{MetaData262 v0} first computes the AST of the test using the \texttt{Esprima} parser and then traverses the AST to obtain all the keywords used in the test. Finally, it labels the test with the version of the latest keyword (as discussed above). 
%
  \item \emph{Hybrid Approach:}
The hybrid approach is calculated using the results of the dynamic and static approaches. The hybrid approach merges the results by maintaining the higher version detected between each approach for each test. For instance, if the dynamic approach's result for a test is version 6 and the static's result for the same test is version 8, then, the test is labeled as belonging to version 8 of the standard according to the hybrid approach.
\end{itemize}


\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/waterfall_model.png}
    \caption{Waterfall model of the dynamic approach to calculate the ECMAScript version}
    \label{fig:waterfall_model}
\end{figure}



% Para6 --> Built-in Computation 
\paragraph{Calculation of built-ins metadata}
The \texttt{built-ins} used by each test are calculated using two separate approaches: dynamic and static. As in the calculation of the \texttt{ECMAScript} version both approaches are combined to improve the results. Below, we describe each approach separately:

\begin{itemize}
  \item \emph{Static Approach:}
The static approach maintains an internal map associating each built-in method and property with the name of the corresponding  built-in object (e.g. the method hasOwnProperty is associated with the built-in object \texttt{Object}). The static approach first computes the AST of the test using \texttt{Esprima} and then traverses the AST checking for each method and property for the built-in object it is associated with. In the end, it outputs a JSON object mapping each built-in object to an array with the names of its methods and properties that the test uses. 
%
  \item \emph{Dynamic Approach:}
The dynamic approach works by running the actual code of the test and logging the interactions of the test with the JavaScript built-ins. To this end, \texttt{MetaData262 v0} wraps the methods of every built-in object in an auxiliary function that calls the corresponding methods and adds an entry to the log registering that call. Finally, \texttt{MetaData262 v0} analyses the log information to determine the built-in methods used by the test. 
\end{itemize}



\section{Related Work}
\label{sec:Related Work}

There is a wide range of scientific studies on program analysis for JavaScript, including: type systems (\cite{Type_Analysis_for_JavaScript}, \cite{Towards_Type_Inference_for_JavaScript}, \cite{Understanding_TypeScript},  \cite{Fast_and_precise_hybrid_type_inference_for_JavaScript}, \cite{Depedent_Types_for_JavaScript}, \cite{Safe_&_Efficient_Gradual_Typing_for_TypeScript},  \cite{Type_Inference_for_Static_Compilation_of_JavaScript}), abstract interpreters (\cite{SAFE:Formal_Specification_and_Implementation_of_a_Scalable_Analysis_Framework_for_ECMAScript}, \cite{JSAI:a_static_analysis_platform_for_JavaScript}, \cite{Scalable_and_Precise_Static_Analysis_of_JavaScript_Applications_via_Loop-Sensitivity},  \cite{Combining_string_abstract_domains_for_JavaScript_analysis:an_evaluation)}), \emph{points-to} analysis (\cite{Points-to_analysis_for_JavaScript}), Hoare logic (\cite{Javert-2017}, \cite{Javert-2019}), operational semantics (\cite{JSCert-2014}, \cite{KJS-2015}, \cite{JSExplain-2018}), intermediate representations and compilers (\cite{Dynamic_property_caches:a_step_towards_faster_JavaScript_proxy_objects}). Here, we focus only on the related work most relevant for this thesis, covering all the most relevant academic efforts in modelling the JavaScript semantics.

One of the first formal semantics of the JS language was presented by Thiemann~\cite{Thiemann-2005} as part of his work on defining a type system for JavaScript. Thiemann's semantics targets the third version of the language and is specified in small-step style. Importantly, this semantics ignores a number of important features of the JavaScript language, such as implicit type coercion, the treatment of global variables, and the non-strict mode. 

In 2008, Maffeis et al. proposed the first operational semantics for a significant subset of ECMAScript~\cite{operational_semantics_javascript-2008}. They target the 3rd version of the language. This semantics was formalized in big-step style and comprises a large collection of rules. Unfortunately, the semantics has not been automated, meaning that it cannot be tested. Nevertheless, the authors use the proposed semantics to reason about various security properties of JS web applications. 

In 2010, Guha et al define lambdaJS~\cite{essence_javascript-2010}, a lambda calculus to be used as a compilation target for JavaScript. The authors claim that lambdaJS capture the fundamental behavior of the JS language. The authors also define a desugaring function that compiles ES 3 programs to lambdaJS and implement a lambdaJS interpreter in Racket. However, the authors do not test their infrastructure against Test262. In order to test this work against Test262, one would have to compile all Test262 tests to lambdaJS and then run the compiled test suite using the lambdaJS interpreter. Importantly, the lambdaJS infrastructure does not support the entire ES3 standard. Hence, if one was to test the proposed infrastructure, one would first have to clearly define the target subset of ES3 and filter the appropriate tests from Test262. Later, the same authors propose S5~\cite{Politz-2012}, an extension of lambdaJS to the 5th version of the standard. In contrast to lambdaJS, which the authors did not test, the authors do test S5, running it against Test262. They pass a total of 8157 tests out of a total of 11606 tests (approx. 70\%). However, the authors admit that they do not implement the whole language, stating that they only implement 60\% of the built-in objects. Nevertheless, they were not able to filter the tests appropriately to include only the tests with the features that they do implement. This means that they might have bugs in features that they implement that were disregarded as being caused by unimplemented features. Without an appropriate labeling of the tests, the only way of guaranteeing that they are not failing tests that they should be passing is to analyze all failing tests manually, which the authors do not do. 

In 2014, Bodin et al. present JSCert~\cite{JSCert-2014} a formal semantics of JavaScript implemented in the Coq proof assistant~\cite{Coq}. JSCert targets the 5th version of the standard and is written in pretty-big-step style~\cite{Arthur-Chargueraud_ESOP_2013}. Besides the semantics, the authors also implement a JS interpreter in Coq~\cite{Coq} called JSRef. They prove that JSRef is correct with respect to JSCert and use the extraction mechanism of Coq to obtain an executable version of JSRef in OCaml~\cite{OCaml}. Using the OCaml version of JSRef, the authors were able to test JSCert/JSRef against Test262. JSRef passes 1796 tests out of a total 2782 tests for the core language. Note that the tests for the core language include all the test that do not explicitly target the built-in objects. Given that JSCert models the entire core language, the following question naturally arises: how come does JSCert fail around 35\% of the tests targeting the core language? The answer is simple: many tests targeting the core language interact with built-in objects, such as arrays, strings, the methods of the Object object, the methods of the Math object etc. Again, the authors were not able to automatically filter the Test262 tests for the tests that do not make use of built-in objects.
%
Later, some the authors of JSCert developed an extension of the JSCert project in which they connected JSRef with the V8 Array implementation. More concretely, instead of implementing the array methods directly in Coq, the authors used the JavaScript implementations of these methods that came with the V8 JS engine. The authors then tested the extended version of JSRef against Test262 passing 2440 tests out of 2782 tests. Note that even with the V8 array library some tests fail. This can be caused by the fact that they make use of other built-in object or because there actually bugs in the JSCert/JSRef implementation. In order to understand the precise reasons, one would have to manually inspect all the failing tests.

In 2015, Park et al develop KJS~\cite{KJS-2015} a formalization of the 5th version of the ECMAScript standard in K re-writing framework. KJS is written in small-step style and allows for symbolic reasoning over JS programs through the symbolic facilities of the K framework. KJS was tested against Test262 passing  2782 tests out of a total of 2782 tests for the core language. Interestingly, the total number of tests presented for the core language in the KJS paper does not coincide with the number presented in the JSCert project. This discrepancies make the results of these papers difficult to assess. One of the goals of this thesis is precisely to improve this situation by establishing a ground truth.

Recently, Chargueraud et al. developed JSExplain~\cite{JSExplain-2018}, a new JavaScript reference interpreter written in a subset of OCaml. JSExplain is written in big-step style with the goal of being as close as possible to text of the standard. JSExplain comes with a compiler from the used subset of OCaml to JavaScript, using which one can interpret JavaScript programs directly in JavaScript. With this compiler, the authors develop a new JavaScript code stepper with which the developer can code step not only their own code but also the code of the JavaScript interpreter. JSExplain is also tested  against Test262.The authors do not provide a detailed break down of the tests, reporting only that JSExplain passes more than 5000 tests. Again, a precise evaluation would require a clear definition of the targeted features of the language and the selection of the corresponding tests. With MetaData262, this can be done easily.

Finally, JISET~\cite{JISET-2020} was the last JS reference interpreter developed by the research community. It targets the 10th version of the language and its code is semi-automatically generated from the HTML version of the specification. Unsurprisingly, the authors also test JISET against Test262, reporting that it passes  16355 tests out of a total of 35990 tests. The authors justify the high failing rate by stating that they do no model most of the JS built-in objects. However, the failing tests might or might be related to unmodelled features. Again, in order to ensure that the failing tests were caused by unmodelled features, one would have to analyze all of them manually, which is impractical given the high number of tests.


\section{Design and Methodology}
\label{sec:Design and Methodology}



We recall that this thesis has two goals. Firstly, we want to improve MetaData262 v0 in two ways: add support for missing metadata elements, and improve the infrastructure for the metadata computation, making the obtained metadata more reliable and the process faster and reproducible. Secondly, we want to create a visualization system for easy selection of tests and display of test statistics.


\subsection{Improvements to MetaData262 v0}
\label{sub:improvements_to_metadata262_v0}


% Para1 --> problemas do calculo da metada existente na Metadata262 v0. 
% --> as versoes estao mal calculadas porque nao existem JS engines 
% que implementem exactamente uma versao e so essa versao 
% --> versoes calculadas em instalacoes ad-hoc 
% -- Ã© preciso melhorar a analise dinamica considerando mais JS engines 
% --> os built-ins tb estao mal calculados porque a analise dinamica 
% dos built-ins ignora propriedades -> so considera chamadas a funcoes 
% por isso, se um teste for apenas: Array.prototype.pop = 3; 
% nao vai ser identificado como um teste que usa o array pela analise 
% dinamica 
% --> ha informacao em falta 
% ficheiros da harness e funcoes da harness
% data de criaÃ§Ã£o do teste 
The metadata calculated by \texttt{MetaData262 v0} is flawed in several ways: in the version calculation, in the built-in calculation, and in the harness calculation. We describe these flaws and how to fix them in more detail next.

\begin{itemize}
\item \emph{Version Calculation} - The version calculation is flawed in both the static and dynamic approaches, meaning that the hybrid approach that uses the results of the previous two will also be compromised. The static approach is flawed since the \texttt{Esprima} parser only fully supports up to \texttt{ECMAScript} version 7. Improvements can be made by finding a \texttt{JavaScript} parser that supports a later version of the standard. The dynamic approach's flaw lies in the way it works, since there is no JS engine that fully supports a version of the standard and only that one. To improve the dynamic approach we will add more JS engines. By adding more data points to the calculation, we will increase the reliability of the obtained metadata.
%
\item \emph{Built-in Calculation} - The built-in calculation is also flawed in both the static and dynamic approaches. The static approach has the same flaw since it also uses \texttt{Esprima} as parser. Therefore the same improvement can be made by finding a newer parser. As for the dynamic approach, it is flawed due to the fact that only function calls are logged and therefore detected. If the properties of a built-in are changed directly then it will not be detected. For example if a test performs \texttt{Array.prototype.pop = 3;} then the property \texttt{prototype} of the Array built-in will be changed even though no function call was made. This can not be detected by the current dynamic approach.
%
\item \emph{Harness Calculation} - The \texttt{harness} calculation is not done, including only the little information available in the \texttt{Frontmatter} of a few tests. This calculation can be improved by completing \texttt{includes} metadata and adding an additional \texttt{harness-functions} metadata. Both \texttt{includes} and harness-functions are mentioned in earlier sections, the first stores the files of the \texttt{harness} needed to run the test and the second will store the functions from those files that are actually used in the test.
\end{itemize}


% Para 2 --> Scalability/Performance and Replicability of the calculation
% 5.1 - Precise Metadata for test262 tests 
% --> calcular a metadata precisamente e de forma facilmente reproducible 
% 5.1.1 versao -> 
% Montar um sistema escalavel para o calculo das versoes 
% associamos a cada versao um numero arbitrario de docker images cada uma 
% com um JS engine supostamente dessa versao 
% ---> parelelizacao etc
% 5.1.2 built-ins -> melhorar a instrumentcao para o calculo dinamico dos 
% built-ins --> em particular, apanhar property look-ups dinamicamente
An important contribution of this thesis is the set up of an automated infrastructure for the computation of the metadata. As discussed above, the dynamic computation of the ES version of each test, requires running various versions of multiple JS engines. So far, in order to do so, these engines must be installed in the local machine running the dynamic-version-computation script. This is impractical as we consider a larger number of engines. To ameliorate this issue, we plan to use docker containers, assigning a docker container to each version and making all the containers available as part of our metadata computation infrastructure. This architecture will enable us to parallelize the work of the dynamic approaches by multiplying the docker containers that run the JS engines. This parallelization will allow scalability because otherwise since the duration to calculate the version with the dynamic approach will scale linearly with the amount of engines per standard version being used. Docker containers will not only improve the performance but also allow MetaData262 to be replicated in an easier way since it requires a smaller configuration effort to replicate the \texttt{MetaData} calculation.


\subsection{MetaData262Viz}
\label{sub:metadata262_visualization_system}

% --> Problemas de acesso a metadata e obtencao de informacao estatistica 
% sobre os testes 
% --> neste momento quem quiser obter informacao estatisca sobre os 
% testes tem de interagir com uma base de dados Mongo e depois processar a informacao 
% como entender
% O objectivo desta tese Ã© resolver estes dois problemas.

% Para 0 --> Motivar a criacao do system de visualizacao
The \texttt{MetaData262Viz} appears to ease the barrier to access the \texttt{MetaData262 v0} information and statistics. Right now the metadata is hosted in a MongoDB database leading to the need to have knowledge of MongoDB to get the information. After getting the information there would most likely be a need to process that metadata and maybe even generating charts to provide statistics. This visualization system will make this process much easier.

% 5.2 - MetaData Visualisation System 
% portal para visualizacao da metadata dos testes + informacao estatisca sobre os testes 
% --> gerar automaticamente 
% --> print screens do que ja fez
% --> discussao das bibliotecas que vai considera usar para criacao e display 
% da informacao estatisca
% --> Exemplos de graficos a gerar 
% -- ...

% Para 1 --> O que o website vai mostrar e o que para isso e' necessario fazer
The \texttt{MetaData262Viz} is in its core a web application that allows users visualize and filter the \texttt{Test262} metadata easily. The system will also update itself whenever there are changes in \texttt{Test262}. Users are able to filter the metadata by the built-ins and version of the test. Users will also be able visualize the queried information in different ways: \texttt{PATH}, \texttt{JSON}, and \texttt{STATS}. The \texttt{PATH} will only show the path to the tests in \texttt{Test262}. The \texttt{JSON} will allow the users to see the full metadata calculated for the tests. Finally, the \texttt{STATS} will show some statistics about the tests queried. To ensure that the information is up to date, this system needs to update itself since this is a thesis project and there is no active developer team. In order to accomplish that, the system will need check for changes, be it in the form of new tests or changes to existing ones, and calculate the new metadata.


% Para 2 --> O que ja esta feito
The development of the web application has already began, Figure \ref{fig:website} shows the progress already made. The image has 2 main parts: the filters part, and the information part.
%
The upper part is the filters part, where it is possible to select the filters for querying the metadata. The first filter, \texttt{BuiltIn Belongs} allows to select tests from the subfolders of the built-in folder in the \texttt{Test262}. The \texttt{BuiltIn Contained} enables the user to filter tests by the built-ins the tests can use.
%
The \texttt{BuiltIn Belongs} and \texttt{BuiltIn Contained} filters are combined using \texttt{AND} or \texttt{OR} relations. The \texttt{AND} relation will only return tests that satisfy both filters. As for the \texttt{OR} relation, it will return every test that satisfies either of the filters.
%
Then, we have the \texttt{Version} filter that allows filtering the tests by the \texttt{ECMAScript} version. Next, we have the \texttt{BACKEND SEARCH} and \texttt{LOCAL SEARCH} search buttons that will query the metadata database for the tests that satisfy the filters set. The \texttt{BACKEND SEARCH} filter the tests in the backend server while the \texttt{LOCAL SEARCH} it will filter the tests in the machine that is used to access the website.
%
In the example, the filters selected are \texttt{Object}  and \texttt{Array} for the \texttt{BuiltIn Belong} and \texttt{BuiltIn Contained} respectively with an \texttt{AND} relation and the sixth version is also selected.
%
The information part of the image contains the result of the query. The information can already be displayed in two of the three ways mentioned above, in the image the \texttt{PATH} is selected. The image also shows it took 16 milliseconds to have the query results available to the user. The image displays that a total of 32 tests satisfy the filters selected. The image shows the path of the tests selected. Note that not all tests are shown at the same time, in order to improve performance only 10 tests are shown at a time, at the bottom of the image is the pagination menu.
% QUESTION mudar o titulo do website para MetaData262 Visualization System ??


% printscreens do site 
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/website.png}
    \caption{Website for searching the metadata in construction}
    \label{fig:website}
\end{figure}


% Para 3 --> Trade off the fazer a filtragem local or no servidor
Figure \ref{fig:website} shows two approaches to the search functionality: server-side search (\emph{Backend Search}) and client-side search (\emph{Local Search}). We provide both approaches because each has its trade offs. The following results were achieved using the laptop that was serving the web application. The server-side search starts slowing down whenever the amount of tests being returned surpasses 2500, taking roughly half a second to get the results. Whereas, the client-search takes around 4 seconds to load all the metadata from the server at page load but is able to filter any query within a few milliseconds. We believe the client-side search to be the most appropriate since is only needs the initial load time. In addition to that, the user can fill in the filters for the search while the data is loading. To further improve this issue, we will be caching the metadata in the users browser this way the metadata would only be loaded once.

% TODO rescrever tudo com comentarios do prof
% Para 4 --> Os graficos que queremos gerar --> bibliotecas
The second use case of the web application is to allow the user to view statistical information about the tests and the queried tests in the form of a variety of charts, such as pie charts, bar charts and box and whiskers charts and stacked bar charts. In his thesis, M. Trigo generated some statistical data about the entire Test262 test suite by hand, introducing the relevant data in a spreadsheet software and then constructing the charts manually. Here, we intend to automate this process, generating those graphs in real time with the help of a JS graphical library. For instance, Figures 9 and 10 illustrate two graphs generated by M. Trigo:

\begin{itemize}
\item \emph{Figure \ref{fig:grafico_bigodes}} show a box and whiskers chart about the number of assert statements that are used in each category.
\item \emph{Figure \ref{fig:grafico_stackBar}} show a stack bar chart with the amount of tests distributed by version in each category.
\end{itemize}

In order to generate such graphs in real time, we are considering two libraries:

\begin{itemize}
\item \emph{KendoReact\cite{KendoReact} -} This library a UI library that makes available to React 126 components. Of those 126 components one is \emph{Charts} with a total of 16 charts available. KendoReact is a very popular UI library for React.
\item \emph{Victory\cite{Victory} -} This library focuses on chart generation. Victory has a total of 34 components directly related to chart generation. Victory is also open-source and one of the most popular chart libraries for React.
\end{itemize}

So far, we are more inclined to use Victory because because we only need the Chart components. Victory is also one of the most popular chart libraries with a big community which might be a big advantage if implementation difficulties arise. 


\begin{figure}
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=0.95\textwidth]{images/n_asserts.png}
  \captionof{figure}{M. Trigo chart number of asserts by category}
  \label{fig:grafico_bigodes}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=0.95\textwidth]{images/version.png}
  \captionof{figure}{M. Trigo chart versions by category}
  \label{fig:grafico_stackBar}
\end{minipage}
\end{figure}


% Para 5 --> breve descricao do processo para manter a metadata atualizada
% ignorado por estar com 3 paginas so' sobre o website


\section{Evaluation and Planning}
\label{sec:Evaluation and Planning}


% Evaluation 
% - Discutimos avaliaÃ§Ã£o das duas componentes do projecto 

% Componente 1 -> sistema para calculo da metadata
% Ã muito difÃ­cil de avaliar porque nÃ£o hÃ¡ ground truth -> nÃ³s nÃ£o sabemos qual Ã© a versÃ£o dos testes
% - vamos seleccionar um conjunto aleatÃ³rio de testes e analisa-los Ã  mÃ£o comparando a versÃ£o calculada com a versÃ£o que sabemos ser a versÃ£o do teste 
% - vamos tb determinar a versÃ£o utilizando Ã  data em que o teste foi inserido na Test262 -> pela data sabemos a versÃ£o corrente -> vamos olhar particularmente para os testes em que a versÃ£o calculada difere da versÃ£o da data dos testes 
% -> AtenÃ§Ã£o que a versÃ£o Ã  data do teste nÃ£o Ã© necessariamente a versÃ£o do teste -> mas dÃ¡ uma indicaÃ§Ã£o
% --> testes analisados manualmente sÃ£o os testes para os quais hÃ¡ grandes discrepÃ¢ncias entre a versÃ£o Ã  data do teste e a versÃ£o calculada para o teste

% Componente 2 -> sistema de visualisacao
% -- testes unitÃ¡rios para testar as funcionalidades base da aplicaÃ§Ã£o 
% -- end-to-end tests -> testes do front-end

% Para 1 --> components a serem testados
The evaluation of this thesis will focus on its two main elements: the metadata calculation infrastructure and the \texttt{MetaData262Viz}. The metadata calculation infrastructure will be evaluated with respect to its precision and performance. As for the \texttt{MetaData262Viz}, it will be evaluated for its reliability. The evaluation criteria will be described in more detail bellow.

% Para 2 --> Metadata calculation precision  
\paragraph{Metadata calculation precision}
The precision of the metadata calculated is very hard to access since there is no ground truth available. The version metadata calculated is being calculated for the first time. To evaluate the precision of the metadata calculation we will analyze a small subset of the Test262 tests manually, comparing the version calculated with their real version. We will use two separate strategies for selecting tests for manual inspection: 
\begin{itemize}
\item \emph{Random Strategy:} we will select a small subset of tests randomly, guaranteeing uniform coverage of the various test folders; 
%
\item \emph{Heuristic Selection:} we will select the tests that exhibit the largest different between the computed version and the version that was the latest at the time the test was added to \texttt{Test262}. To do this, we will extend the metadata of the tests with the date in which they were added to Test262 or updated. It is often the case that tests are added for features of previous versions; this happens for instance when Test262 maintainers detect missing coverage issues, in such cases the newly added tests target the version that was active when the corresponding uncovered feature was introduced instead of the current one.
\end{itemize}


% Para 3 --> Metadata calculation performance
\paragraph{Metadata calculation performance}
To evaluate performance improvements made to \texttt{MetaData262 v0} we will compare the time needed to perform the metadata calculation between the old and new infrastructures. This must be run in the same system and with the least concurrent processes running in order to make sure we have the least interference, this way achieving the most trustworthy results.



% Para 4 --> visualization system
\paragraph{MetaData262Viz reliability}
The MetaData262Viz evaluation will have three types of tests: unit tests, end-to-end tests and load tests. The unit tests will ensure the correctness of the system's results. The end-to-end tests will guarantee that the website interface works correctly. Finally, the load tests will allow us to estimate the amount of users that the system can support, this way allowing us to estimate the resources need.



\subsection{Planning}
\label{sub:planning}

% subsection planning (end)
% Planning -> usar texto equivalente ao Miguel Trigo 
% - Melhoria do sistema de calculo da metadata - 2 meses
% - ConclusÃ£o do sistema de visualizaÃ§Ã£o - 2 meses
% - AvaliaÃ§Ã£o - 1 mÃªs 
% - Thesis Writing - 2 meses 
% Julho - (Agosto fÃ©rias) - Novembro

The Plan for this thesis is based on the tasks that need to be performed in order to accomplish the objectives defined in Section \ref{sec:Goals}. Thus, this thesis has 4 main task to accomplish: improving the metadata calculation, concluding the MetaData262Viz, evaluating the results, and writing the thesis. These tasks are represented in the Gantt diagram in Figure \ref{fig:gantt} and each task is described in more detail afterwards. Note that the month of August has a grey background due to it being a vacations period.


\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/gantt_thesis_month.png}
    \caption{Gantt diagram with the thesis plan}
    \label{fig:gantt}
\end{figure}



\paragraph{Improving metadata calculation}
This task consists of improving \texttt{MetaData262 v0} by improving its precision and performance as discussed in Section \ref{sec:Design and Methodology}. The precision will be improved with the inclusion of more JS engines and a JS parser that supports more recent versions of the standard. As for the performance, we will parallelize the metadata calculation using \texttt{docker} containers.


\paragraph{Concluding MetaData262Viz}
This task consists of concluding \texttt{MetaData262 v0} visualization system by adding the possibility to view statistics about the queried tests and improving the system's reliability.


\paragraph{Evaluation}
This task consists of evaluating the results of the metadata generated. We will manually check the metadata calculated for a small subset of Test262 tests, using the selection strategies discussed in this. The development of the tests for the MetaData262Viz and the system itself will overlap during the first two weeks of the evaluation.


\paragraph{Writing the thesis}
This last task will consist of reporting the execution of the previous tasks, by presenting the results obtained as well as the conclusions reached after finishing this project.




\section{Conclusion}
\label{sec:Conclusion}
With this thesis we will build an infrastructure that enables convenient access to the metadata of the \texttt{Test262} test suite. We will improve the metadata calculation of \texttt{MetaData262 v0} and make it accessible to users via a web interface. This will enable \texttt{JavaScript} engine developers to filter tests easily, in particular developers of partial implementations. This will allow developers to find and correct errors more quickly and also enable a standardization of test selection process for partial implementations.



%
% the environments 'definition', 'lemma', 'proposition', 'corollary',
% 'remark', and 'example' are defined in the LLNCS documentclass as well.
%

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\bibliographystyle{splncs04}
\bibliography{references}

\end{document}
